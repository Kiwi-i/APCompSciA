<!DOCTYPE html> 
<html> 
<head>
    <link rel="stylesheet" href="../styles/notes.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Over+the+Rainbow" rel="stylesheet">
</head>
<body>
<div id="top">
    <h1>Set 25: Abstract Classes and Interfaces</h1>
</div>
<div id="skills">
    <ul id="skillsList">
        <li>
            Skill 25.1 <a href="#skill1">Explain the purpose of an abstract class</a>
        </li>
        <li>
            Skill 25.2 <a href="#skill2">Implement an abstract class<strong>extends</strong></a>
        </li>
        <li>
            Skill 25.3 <a href="#skill3">Explain the purpose of an interface</a>
        </li>
        <li>
            Skill 25.4 <a href="#skill4">Implement an interface</a>
        </li>
    </ul>    
</div>
<div id="skill1" class="skills">Skill 25.1 Explain the purpose of an abstract class</div>
<div class="skillConceptsHeader">Skill 25.1 Concepts</div>
<div class="skillConcepts">
        <p>
                Suppose that for some reason, we had a programming task that was to model animals. For
                example, we want to have a class for a cat, a class for a dog, a class for a horse, and so forth. As
                you can imagine, there could be lots of redundancy among those classes because animals have
                some common characteristics. For instance, all animals have, say, two eyes, or two ears, and
                make sounds, and so forth. Or at least all the animals that we would like to model do.
        </p>
        <p>
                We could create a super class called animal to capture all these common characteristics and
                behaviors. And then we could have all the specific animal classes derive from the animal class.
                So far so good…
        </p>
        <p>
                The question though is, what would new animal mean? In other words, if we create an object of
                the animal class, what kind of object would that be? What would we try to model by creating an
                object of the animal class?
        </p>
        <p>
                You may be thinking there is no point in creating objects from the animal class, so there is no
                need to ever invoke the animal constructor. But subclasses could benefit from extending such a
                class.
        </p>
        <p>
                Java prohibits, under some circumstances, creating objects from specific classes. Such classes are
                referred to as abstract classes. Abstract classes are classes that cannot be instantiated – objects
                cannot be created from abstract classes. While the methods abstract classes carry may be
                implemented, methods declared as abstract cannot be implemented by the abstract class, they
                must instead be implemented by the subclass. Such methods can provide a framework for a
                subclass.
        </p>

        <div class="skillTakeAway"><p>Objects cannot be created from abstract classes</p></div>
        <div class="skillTakeAway"><p>Methods declared as abstract cannot be implemented by the abstract class, they
                must instead be implemented by the subclass</p></div>
        <div class="practice">
            <a href="../ticketOutTheDoor/set25/Set25TicketOutTheDoorAPCompSciA.pdf" target="_blank">Skill 25.1: Exercise 1</a>
        </div>
</div>
<div id="skill2" class="skills">Skill 25.2 Implement an abstract class</div>
<div class="skillConceptsHeader">Skill 25.2 Concepts</div>
<div class="skillConcepts">
<p>Abstract classes are implemented using the keyword <strong>abstract</strong></p>
<p>In the below example, we have created an abstract class called <em>animal</em></p>
    <div class="codeblock"> 
        <p>public abstract class Animal
        <br>{</p>  
        <p>//methods and fields</p>     
        <p>}</p>    
    </div>
<p>As previously mentioned, abstract classes can provide the framework for a subclass.  
    For example, consider the following subclasses which inherit the animal class,
</p>
    <div class="codeblock"> 
        <p>public class Cow extends Animal
        <br>{</p>  
        <p>//methods and fields</p>     
        <p>}</p>    

        <p>public class Dog extends Animal
        <br>{</p>  
        <p>//methods and fields</p>     
        <p>}</p>    
     
        <p>public class Cat extends Animal
        <br>{</p>  
        <p>//methods and fields</p>     
        <p>}</p>    
    </div>
<p>Each of the classes that inherit the parent class, Animal, have some common characteristics.
    For example, a Cow, a Dog, and a Cat, all have two eyes, two ears, and
    make sounds, and so forth. But these charasterics are different for each animal we 
    want to model.
    
</p>
<p>Suppose we want to ensure that every animal we model can speak.   To do this, we would
    write an abstract method in our abstract class.  
</p>
<div class="codeblock"> 
        <p>public abstract class Animal
        <br>{</p>  
        <p>     public abstract void speak();</p>     
        <p>}</p>    
</div>
<p>Notice we have only declared the abstract method, but we did not implement it.  In fact,
    Java does not allow for this.   However, the classes that inherit the Animal class <em>must</em>
    implement the speak method.</p>
</p>

<p>This is illustrated below,</p>

<iframe height="600px" width="100%" src="https://repl.it/@hpluska/Set26Skill21?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>  

    <p>
        The above illustrates how abstract classes can serve as a framework for subclasses.  
        In addition to abstract methods, abstract classes can also include regular methods.
        For example, all the animals in our subclasses have four legs, therefore we can 
        create a method to return the number of legs in the parent class. 
    </p>
    <div class="codeblock"> 
            <p>public abstract class Animal
            <br>{</p>  
            <p>     public abstract void speak();</p>  
            <p>     public String getLegs(){<br>
                        return "Four";<br>
                    }
            </p>   
            <p>}</p> 
    </div>   
            <iframe height="400px" width="100%" src="https://repl.it/@hpluska/Set26Skill22?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

    <div class="practice">
            <a href="../ticketOutTheDoor/set25/Set25TicketOutTheDoorAPCompSciA.pdf" target="_blank">Skill 25.2: Exercise 1</a>
    </div>

</div>
<div id="skill3" class="skills">Skill 25.3 Explain the purpose of an interface</div>
<div class="skillConceptsHeader">Skill 25.3 Concepts</div>
<div class="skillConcepts">

    <p>An interface is an abstract super class that contains only abstract methods.  
        Consider the following example.
    </p>
    <p>The super class:</p>
    <div class = "codeblock">
            <p>public abstract class Parent<br>
            {<br>
            public abstract void method1();<br>
            public abstract void method2();<br>
            public abstract int method3(double d);<br>
            }</p>
    </div>
    <p>And now the subclass:</p>
    <div class = "codeblock">
            <p>public class Child extends Parent<br>
            {<br>
            public void method1(){ … some code … }<br>
            public void method2(){ … some code … }<br>
            public int method3()(double c) { … some code … }<br>
            }</p>
    </div>
    <p>Notice that in the above example, the super class does nothing. In other words, all methods in the
    super class are abstract. Moreover, there are no variables which need to be accessed. The only
    purpose of the super class is to force the subclass to implement its methods. If this is all a
    particular super class does, then the “abstract” declaration can be replaced with an interface as
    shown below,</p>

    <div class="codeblock">
        <p>
                public interface Parent<br>
                {<br>
                void method1();<br>
                void method2();<br>
                int method3(double d);<br>
                }
        </p>
    </div>

    <p>Notice, that with the methods above, it would be legal to start their signatures with public abstract,
            however, even if we leave them off, they are automatically public and abstract… all because it is
            an interface. It is conventional in interfaces <em>not</em> to use public and abstract in the signatures.</p>
    <p>
            Finally, because the parent class has been changed to an interface, the subclass must also be changed,
    </p>
    <div class = "codeblock">
        <p>
                public class Child implements Parent<br>
                {<br>
                public void method1(){ … some code … }<br>
                public void method2(){ … some code … }<br>
                public int method3()(double c) { … some code … }<br>
                }
        </p>
    </div>

    <p>
            In the subclass, the word <strong>extends</strong> has been replaced with <strong>implements</strong>. Everything else is the
            same. Notice, that all the interface does here is to force us to implement those methods in the
            subclass… big deal! Actually it is a very big deal, as the interface provides the structure that the
            subclasses must adhere to.
    </p>

    <div class="skillTakeAway"><p>All the methods in an interface are abstract</p></div>
    <div class="skillTakeAway"><p>An interface provides the structure for the subclass.  That is, 
        all methods in the interface, must be implemented in the subclass
    </p></div>
<div class="practice">
        <a href="../ticketOutTheDoor/set25/Set25TicketOutTheDoorAPCompSciA.pdf" target="_blank">Skill 25.3: Exercise 1</a>
</div>
</div>
<div id="skill4" class="skills">Skill 25.4 Implement an interface</div>
<div class="skillConceptsHeader">Skill 25.4 Concepts</div>
<div class="skillConcepts">

        <p>An interface is implemented using the keyword <strong>implements</strong></p>
        <p>Consider the interface below, </p>

        <div class = "codeblock">
            <p>public interface RobotArm<br>
            {<br>
                void moveUp( double rate, double howFar );<br>
                void moveDown( double rate, double howFar );<br>
                void twistLeft( double deg );<br>
                void twestRight( double deg );<br>
            }
            </p>
        </div>

        <p>The robot interface created above provides the “glue” that holds together several cooperating classes
            shown below, specifically two different industrial robots supplied by two different robot manufacturers.
            They are the Lexmar 234 and the General Robotics 56A.</p>

        <table>
            <tr>
                <td valign="top">
                        <div class = "codeblock">
                                <p>
                                public class Lexmar234 implements RobotArm<br>
                                {<br>
                                    public Lexmar234() { //constructor }<br>
                                    public void moveUp(double rate, double howFar) {<br>
                                        //some code }<br>
                                    public void moveDown(double rate, double howFar) {<br>
                                        //some code }<br>
                                    public void twistLeft( double deg ) { //some code }<br>
                                    public void twistRight( double deg ) { //some code }<br>
                                }
                                </p>
                            </div>
                </td>
                <td valign="top">
                        <div class = "codeblock">
                                <p>
                                public class GR56A implements RobotArm<br>
                                {<br>
                                    public Lexmar234() { //constructor }<br>
                                    public void moveUp(double rate, double howFar) {<br>
                                        //some more code }<br>
                                    public void moveDown(double rate, double howFar) {<br>
                                        //some more code }<br>
                                    public void twistLeft( double deg ) {<br>
                                        //some more code }<br>
                                    public void twistRight( double deg ) {<br>
                                        //some more code }<br>
                                        }
                                </p>
                        </div>
                </td>
            </tr>
        </table>
        <p>

                So far there is no difference from the implementation of the abstract class we previously
                discussed. In other words, just like the abstract class, the interface forces us to write code for
                those methods in classes where we specifically implement RobotArm.
        </p>
        <p>
                Now let’s find out what is different about interfaces. In the main Robot
                class below we will create objects from the RobotArm interface… recall this was not allowed
                with abstract classes.
        </p>
        <div class = "codeblock">
                <p>
                public class Robot
                {<br>
     
                    public static void main(String[] args)<br>

                    {<p style="margin-left:50px">
                        RobotArm lx = new Lexmar234();<br>
                        RobotArm gr = new GR56A();<br>
                        //Do something with the Lexmar robot<br>
                        lx.moveDown(3, 27.87);<br>
                        lx.twistRight(22.0);<br>
                        //Do something with the General Robotics machine<br>
                         gr.moveUp(16.1, -23,19);<br>
                        gr.twistLeft(18);
                        </p>
                        }<br>
                        
                }
                </p>
        </div>
        <p>It is significant that nowhere in the above class did we say implements in the code. Also notice,
        for example, that when we declare</p>
        <div class = "codeblock">
                <p>RobotArm lx = new Lexmar234();</p>
        </div>
        <p>That lx is a type RobotArm even though RobotArm is not a class, it is an interface. This is
                specified by the left side of the above statement, and it means that lx can only use methods given
                in the RobotArm interface. The object lx will use these methods as implemented in the
                Lemar234 class. Notice this is specified on the right side of the above statement.</p>

                <div class="skillTakeAway"><p>Objects can be created from interfaces but not from abstract classes
                    </p></div>
                <div class="skillTakeAway"><p>Classes can implement many interfaces, but can only extend one parent class
                    </p></div>
    <div class="practice">
            <a href="../ticketOutTheDoor/set25/Set25TicketOutTheDoorAPCompSciA.pdf" target="_blank">Skill 25.4: Exercise 1</a>
    </div>
</div>
</body>
</html>